## Explain my idea

如果以先處理從右邊到左邊弄完的結果，也就是說如果右邊的數字比左邊大，那我的糖果樹肯定不一樣，是左邊的再加一(盡量少)，如果一樣，為了最少就給他1(重新累加)，假定你有個方法能算出來這種東西
你得到的糖果數目是：

ratings : 1, 2, 87, 87, 87, 87, 2, 1
糖果數  : 1, 2,  3,  1,  1,  1, 1, 1

這時候你從右往左看是沒問題的，但是左往右就很有問題，根據上方想法，再跑一次的結果是
ratings : 1, 2, 87, 87, 87, 87, 2, 1
糖果數  : 1, 2,  3,  1,  1,  3, 2, 1


# 迴圈＊2:
1. 左往右檢查，確保如果右邊比左邊大，他得到的糖果數一定比左邊多
2. 右往左檢查，確保如果左邊比右邊大，他得到的糖果數一定比右邊多

確保兩邊都是合理，那就不可能有錯，有錯表示某一邊比另一側大的時候沒更新到，跟原本的矛盾～

做法：先assign array =  1*len(input) list, 再往上加（盡量最少，且至少有1個）

then, sum(array)

